---



title: 深入理解回调函数
date: 2017-01-10 01:23:08
tags: 回调函数
categories: 编程笔记 
comments: true 
---


![image](深入理解回调函数/Callback-notitle.svg)
><font color=#0000FF face="微软雅黑" size=4>Just call me back!</font>
***

## 一、综述
### 1.1 废话  

&emsp;&emsp;写这篇博客是因为一个朋友最近在问我关于回调函数的事情，虽然之前也看过不少这方面的资料，但一来当时只是“看”懂了，二来平时很少用到，所以对于回调函数的理解只是在一个很肤浅的层面上，知道有这么个东西，大概知道怎么用。刚好借这个机会去深入的理解它——积跬步以至千里！写之前在网上搜索了很久，关于回调函数的资料还是挺多的，只是国内的博客鱼目混珠，质量参差不齐。抄来抄去也就算了，很多连抄都懒得抄全，搞的新手晕头转向，不知所云。所以本文会最大限度的保持原创，并力争做到条理清晰，简洁易懂。

### 1.2 定义  

&emsp;&emsp;国内对于“回调函数”的解释很多，但个人感觉还是不如维基百科的专业和简洁，本文采用维基百科的定义。其原文如下： 
<blockquote2>In computer programming, a **callback**<sub>1</sub> is a piece of executable code that is passed as an argument to other code, which is expected to call back(execute) the argument at some convenient time. The invocation may be immediate as in a **synchronous callback**<sub>2</sub>, or it might happen at a later time as in an **asynchronous callback**<sub>3</sub>. In all cases, the intention is to specify a function or subroutine as an entity that is, depending on the language, more or less similar to a variable.  
&emsp;&emsp;Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.</blockquote2>  

&emsp;&emsp;翻译如下（为了语句通顺，稍微做了修改，能力有限，欢迎指正。）：
<blockquote2>在计算机编程中，**回调**<sub>1</sub>是一段以参数形式传递给其它代码的可执行代码，期望调用代码（其它代码）在某个方便的时候回来调用它。按照调用方式不同分为**同步回调**<sub>2</sub>（如果调用是立即生效的，也称为**阻塞回调**）和**异步回调**<sub>3</sub>（如果调用将在稍后生效，也称**非阻塞回调**）。不管是什么情况，其目的都是要指定一个函数或者子程序为实体，具体情况则取决于编程语言，其作用或多或少的有点类似于变量。  
&emsp;&emsp;不同的编程语言以不同的形式提供回调功能，较为常见的实现方式有子程序，lambda表达式，代码块或者函数指针。</blockquote2>  

&emsp;&emsp;本文第一幅图（摘自维基百科，为了便于阅读对其原图进行了配色）简洁明了的阐明了这种调用关系。图中<code>Main program</code>作为调用发起者（**主调方/调用者**），去调用了<code>Library function</code>中的某个函数（**被调方/被调用者**），而被调方在执行的时候又回过来调用了主调方提供的<code>Callback function</code>函数（**回调函数**）。图中的**红色箭头**即代表**回调**这个过程。  
&emsp;&emsp;<font color=#ff0000>**为了方便后面的叙述，本文约定，凡是主动发起调用请求的称为主调方，被调用的称为被调方。请读者务必注意，后面不再说明。**</font>  
&emsp;&emsp;调用和被调用是一个相对关系，并不是绝对的。仍然以第一幅图为例，从函数层面来说：  
&emsp;&emsp;**刚开始时：** 
&emsp;&emsp;<div align='center'><font color=#0000ff>**主调方**</font>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;==>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<font color=#ff0000>**被调方**</font></div>
&emsp;&emsp;<div align='center'><code>Main program</code>&emsp;&emsp;==>&emsp;&emsp;<code>Library function</code></div> 
 
&emsp;&emsp;**Library function回调时**：  
&emsp;&emsp;<div align='center'><font color=#0000ff>**主调方**</font>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;==>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<font color=#ff0000>**被调方**</font></div>
&emsp;&emsp;<div align='center'><code>Library function</code>&emsp;&emsp;==>&emsp;&emsp;<code>Callback function</code></div>

&emsp;&emsp;再往上走，我们将会得到更清晰的认识，即从框架层面来说：  
&emsp;&emsp;**刚开始时**：
&emsp;&emsp;<div align='center'><font color=#0000ff>**主调方**</font>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;==>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<font color=#ff0000>**被调方**</font></div>
&emsp;&emsp;<div align='center'><code>Application program</code>&emsp;&emsp;==>&emsp;&emsp;<code>Software library</code></div>  
&emsp;&emsp;**回调发生时**：  
&emsp;&emsp;<div align='center'><font color=#0000ff>**主调方**</font>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;==>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<font color=#ff0000>**被调方**</font></div>
&emsp;&emsp;<div align='center'><code>Software library</code>&emsp;&emsp;==>&emsp;&emsp;<code>Application program</code></div>  
### 1.3 回调机制 *VS* 回调函数  

&emsp;&emsp;<font color=#ff0000 size=3>**注意：本节是笔者在搜索大量资料后整理出来的，某些概念并没有权威的定义，读者请自行斟酌是否采纳，纰漏之处请指正。**</font>
&emsp;&emsp;使用关键字“回调机制”进行搜索时，得到的大多数是都是关于回调函数的，也就是说大部分的博客在讲解中并没有把回调机制和回调函数区别开。然而这两者并不完全等价。  
#### 1.3.1 回调机制  
&emsp;&emsp;回调机制有**广义回调**和**狭义回调**之分。  
&emsp;&emsp;所谓**广义回调**，泛指任何采用了回调这种机制的方法或者技术，比如Windows系统的<block>**消息机制**</block>（详细信息可参考相关资料）。而广义回调的实现方式也不仅仅局限于回调函数，比如**消息队列**。  
&emsp;&emsp;所谓**狭义回调**，则特指某种具体回调机制，一般来说，都是指采用了回调函数的回调机制（网上大部分资料也都是关于这种机制的讲解和介绍）。  
&emsp;&emsp;<font color=#aa66ff size=3>由此可知，**回调函数仅仅是回调机制的一种特定实现。**</font>  
#### 1.3.2 钩子函数  
&emsp;&emsp;按照网上的资料，钩子函数仅仅是回调函数的一个特例。比如Windows系统利用钩子函数，可以实现Windows事件的过滤或处理。笔者对Windows系统编程不太熟悉，无法提供更详尽的解释，需要深入了解的请自行参考相关资料。 
## 二、进阶讲义
### 2.1 通俗理解  
&emsp;&emsp;假定我们现在有三个函数A、B、C，在A调用B的时候，把C的地址（整个函数的地址，即函数的入口）作为了参数传递给B，那么C就是我们的回调函数。  
&emsp;&emsp;<font color=#ff0000 size=3>**请牢记这三个函数的对应关系，为方便叙述，下面的讲解都会以A、B、C来代称。**</font>
&emsp;&emsp;通俗来讲，假设你（A）电脑现在有问题了，你搞不定，就打电话给你一个同学（B）求助，要让他给你充分解决问题，你总得提供大量有用的信息或者必要的帮助吧，比如开个远程（C）啥的。  
&emsp;&emsp;所谓同步回调（阻塞回调），就是C函数一定会在A函数返回之前被（B）调用。而异步回调（非阻塞回调），则C函数可能会在A返回之前被（B）调用，也可能是在A返回之后被调用。  
&emsp;&emsp;通俗来讲（接上个例子），你打电话给你同学之后需要出门办事（A函数返回），同步回调就是，在你出门之前，你同学一定会使用你开的远程控制来操作你的电脑，试图给你解决问题（B函数调用C函数）。而异步回调就是，他可能会在你还没出门前使用（远程），也可能会在你出门后使用（远程）。  
### 2.2 代码篇  
### 2.2.1 Python  
```python
#函数你，对应A函数
def you():
    print("A函数启动.      ==>  你用电脑，遇到了问题.\n")
    msg = "我的电脑出了点问题XXX，你帮我看看，给你开个远程."
    print("A函数调用B函数.  ==>  你向你朋友发起求助.\n")
    yourFriend(msg, remoteControl)
    print("A函数返回.    ==>  你出门办事.\n")
    return None

#函数你的朋友，对应B函数    
def yourFriend(msg, call_back):
    print("B函数被调用.    ==>  你朋友收到你的求助.\n")
    actions = ["右键计算机",
               "选择属性",
               "选择高级系统设置",
               "... ...",
              ]
    call_back(actions)
    print("B函数返回.    ==>  你朋友向你反馈处理结果.\n")
 
#函数QQ远程控制，对应C函数   
def remoteControl(actions):
    print("C函数被调用.    ==>  你朋友通过你开的QQ远程操作你的电脑.\n")
    for action in actions:
        print(">> %s" % action)
    print("\nC函数返回.    ==>  处理完毕，退出远程的使用.\n")
   
you()

```
&emsp;&emsp;程序运行结果为：

```python
Output:
A函数启动.      ==>  你用电脑，遇到了问题.
A函数调用B函数.  ==>  你向你朋友发起求助，同时提供 ***远程控制*** 给他.
B函数被调用.    ==>  你朋友收到你的求助.
C函数被调用.    ==>  你朋友通过你开的 ***远程控制*** 操作你的电脑.
右键计算机
>> 选择属性
>> 选择高级系统设置
>> ... ...
C函数返回.    ==>  处理完毕，退出远程的使用.
B函数返回.    ==>  你朋友向你反馈处理结果.
A函数返回.    ==>  你出门办事.
```